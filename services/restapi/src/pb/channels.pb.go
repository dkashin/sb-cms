// Code generated by protoc-gen-go. DO NOT EDIT.
// source: channels.proto

package stabox

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Channel struct {
	XId                  string   `protobuf:"bytes,1,opt,name=_id,json=Id,proto3" json:"_id,omitempty"`
	ChannelId            uint32   `protobuf:"varint,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Channel) Reset()         { *m = Channel{} }
func (m *Channel) String() string { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()    {}
func (*Channel) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{0}
}

func (m *Channel) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Channel.Unmarshal(m, b)
}
func (m *Channel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Channel.Marshal(b, m, deterministic)
}
func (m *Channel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Channel.Merge(m, src)
}
func (m *Channel) XXX_Size() int {
	return xxx_messageInfo_Channel.Size(m)
}
func (m *Channel) XXX_DiscardUnknown() {
	xxx_messageInfo_Channel.DiscardUnknown(m)
}

var xxx_messageInfo_Channel proto.InternalMessageInfo

func (m *Channel) GetXId() string {
	if m != nil {
		return m.XId
	}
	return ""
}

func (m *Channel) GetChannelId() uint32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

type Program struct {
	XId                  string   `protobuf:"bytes,1,opt,name=_id,json=Id,proto3" json:"_id,omitempty"`
	ProgramId            uint32   `protobuf:"varint,2,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty"`
	ChannelId            uint32   `protobuf:"varint,3,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Description          string   `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	StartsAt             uint32   `protobuf:"varint,6,opt,name=starts_at,json=startsAt,proto3" json:"starts_at,omitempty"`
	EndsAt               uint32   `protobuf:"varint,7,opt,name=ends_at,json=endsAt,proto3" json:"ends_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Program) Reset()         { *m = Program{} }
func (m *Program) String() string { return proto.CompactTextString(m) }
func (*Program) ProtoMessage()    {}
func (*Program) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{1}
}

func (m *Program) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Program.Unmarshal(m, b)
}
func (m *Program) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Program.Marshal(b, m, deterministic)
}
func (m *Program) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Program.Merge(m, src)
}
func (m *Program) XXX_Size() int {
	return xxx_messageInfo_Program.Size(m)
}
func (m *Program) XXX_DiscardUnknown() {
	xxx_messageInfo_Program.DiscardUnknown(m)
}

var xxx_messageInfo_Program proto.InternalMessageInfo

func (m *Program) GetXId() string {
	if m != nil {
		return m.XId
	}
	return ""
}

func (m *Program) GetProgramId() uint32 {
	if m != nil {
		return m.ProgramId
	}
	return 0
}

func (m *Program) GetChannelId() uint32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *Program) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Program) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Program) GetStartsAt() uint32 {
	if m != nil {
		return m.StartsAt
	}
	return 0
}

func (m *Program) GetEndsAt() uint32 {
	if m != nil {
		return m.EndsAt
	}
	return 0
}

type Stream struct {
	XId      string `protobuf:"bytes,1,opt,name=_id,json=Id,proto3" json:"_id,omitempty"`
	StreamId uint32 `protobuf:"varint,2,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	Name     string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Enabled_:
	//	*Stream_Enabled
	Enabled_             isStream_Enabled_ `protobuf_oneof:"enabled_"`
	Service              *Service          `protobuf:"bytes,5,opt,name=service,proto3" json:"service,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Stream) Reset()         { *m = Stream{} }
func (m *Stream) String() string { return proto.CompactTextString(m) }
func (*Stream) ProtoMessage()    {}
func (*Stream) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{2}
}

func (m *Stream) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Stream.Unmarshal(m, b)
}
func (m *Stream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Stream.Marshal(b, m, deterministic)
}
func (m *Stream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream.Merge(m, src)
}
func (m *Stream) XXX_Size() int {
	return xxx_messageInfo_Stream.Size(m)
}
func (m *Stream) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream.DiscardUnknown(m)
}

var xxx_messageInfo_Stream proto.InternalMessageInfo

func (m *Stream) GetXId() string {
	if m != nil {
		return m.XId
	}
	return ""
}

func (m *Stream) GetStreamId() uint32 {
	if m != nil {
		return m.StreamId
	}
	return 0
}

func (m *Stream) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type isStream_Enabled_ interface {
	isStream_Enabled_()
}

type Stream_Enabled struct {
	Enabled bool `protobuf:"varint,4,opt,name=enabled,proto3,oneof"`
}

func (*Stream_Enabled) isStream_Enabled_() {}

func (m *Stream) GetEnabled_() isStream_Enabled_ {
	if m != nil {
		return m.Enabled_
	}
	return nil
}

func (m *Stream) GetEnabled() bool {
	if x, ok := m.GetEnabled_().(*Stream_Enabled); ok {
		return x.Enabled
	}
	return false
}

func (m *Stream) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Stream) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Stream_Enabled)(nil),
	}
}

func init() {
	proto.RegisterType((*Channel)(nil), "stabox.Channel")
	proto.RegisterType((*Program)(nil), "stabox.Program")
	proto.RegisterType((*Stream)(nil), "stabox.Stream")
}

func init() { proto.RegisterFile("channels.proto", fileDescriptor_6eb5b11d5b15e5ec) }

var fileDescriptor_6eb5b11d5b15e5ec = []byte{
	// 349 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xc1, 0x4e, 0xc2, 0x30,
	0x18, 0xc7, 0x29, 0xe0, 0x36, 0x3e, 0x22, 0x24, 0xf5, 0xe0, 0x32, 0x35, 0x21, 0x3b, 0xe1, 0x05,
	0x10, 0x4f, 0x7a, 0x43, 0x2f, 0x72, 0x33, 0xe3, 0x01, 0x48, 0xa1, 0x75, 0x36, 0x19, 0xed, 0xd2,
	0x36, 0xc4, 0x97, 0xf1, 0x09, 0x7c, 0x0d, 0x1f, 0xcc, 0xac, 0x2d, 0x73, 0x41, 0x2e, 0xde, 0xd6,
	0xdf, 0xff, 0xfb, 0xfe, 0xfd, 0x7f, 0xfb, 0x0a, 0x83, 0xed, 0x3b, 0x11, 0x82, 0x15, 0x7a, 0x52,
	0x2a, 0x69, 0x24, 0x0e, 0xb4, 0x21, 0x1b, 0xf9, 0x91, 0x5c, 0xe7, 0x52, 0xe6, 0x05, 0x9b, 0x92,
	0x92, 0x4f, 0x89, 0x10, 0xd2, 0x10, 0xc3, 0xa5, 0xf0, 0x55, 0xc9, 0x40, 0x33, 0xb5, 0xe7, 0x5b,
	0xe6, 0xcf, 0xe9, 0x03, 0x84, 0xcf, 0xce, 0x07, 0x0f, 0xa1, 0xb3, 0xe6, 0x34, 0x46, 0x23, 0x34,
	0xee, 0x65, 0xed, 0x25, 0xc5, 0x37, 0x00, 0xfe, 0x8e, 0x8a, 0xb7, 0x47, 0x68, 0x7c, 0x9e, 0xf5,
	0x3c, 0x59, 0xd2, 0xf4, 0x1b, 0x41, 0xf8, 0xaa, 0x64, 0xae, 0xc8, 0xee, 0x64, 0x6f, 0xe9, 0xb4,
	0x46, 0xaf, 0x27, 0x7f, 0xac, 0x3b, 0x47, 0xd6, 0x18, 0x43, 0x57, 0x90, 0x1d, 0x8b, 0xbb, 0xd6,
	0xcf, 0x7e, 0xe3, 0x11, 0xf4, 0x29, 0xd3, 0x5b, 0xc5, 0xcb, 0x6a, 0x9e, 0xf8, 0xcc, 0x4a, 0x4d,
	0x84, 0xaf, 0xa0, 0xa7, 0x0d, 0x51, 0x46, 0xaf, 0x89, 0x89, 0x03, 0xeb, 0x19, 0x39, 0xb0, 0x30,
	0xf8, 0x12, 0x42, 0x26, 0xa8, 0x95, 0x42, 0x2b, 0x05, 0xd5, 0x71, 0x61, 0xd2, 0x4f, 0x04, 0xc1,
	0xca, 0x28, 0x76, 0x6a, 0x0a, 0xeb, 0x58, 0x49, 0xbf, 0x43, 0x44, 0x0e, 0x34, 0x42, 0x76, 0x1a,
	0x21, 0x93, 0xea, 0x16, 0xb2, 0x29, 0x18, 0xb5, 0xd9, 0xa3, 0x97, 0x56, 0x76, 0x00, 0xf8, 0x16,
	0x42, 0xff, 0xf3, 0x6d, 0xf8, 0xfe, 0x7c, 0x38, 0x71, 0x2b, 0x9b, 0xac, 0x1c, 0xce, 0x0e, 0xfa,
	0x13, 0x40, 0xe4, 0xbb, 0xd6, 0xf3, 0x2f, 0x04, 0x91, 0x5f, 0x91, 0xc6, 0x8f, 0x70, 0x91, 0x33,
	0xb3, 0xd8, 0x13, 0x5e, 0x54, 0xb2, 0xcb, 0xad, 0x71, 0xed, 0xe4, 0x0b, 0x93, 0x41, 0x6d, 0x6d,
	0x2b, 0xd2, 0xd6, 0x0c, 0xe1, 0x19, 0x40, 0xce, 0x4c, 0xbd, 0xb1, 0x43, 0x85, 0x07, 0xc9, 0x31,
	0x48, 0x5b, 0xf8, 0x0e, 0xfa, 0x6f, 0x5c, 0xd0, 0x7f, 0xb4, 0x6c, 0x02, 0xfb, 0xac, 0xee, 0x7f,
	0x02, 0x00, 0x00, 0xff, 0xff, 0x26, 0x81, 0xfd, 0x6f, 0x9e, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ChannelsClient is the client API for Channels service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChannelsClient interface {
	GetAvailableStreams(ctx context.Context, in *Channel, opts ...grpc.CallOption) (Channels_GetAvailableStreamsClient, error)
	GetProgram(ctx context.Context, in *Program, opts ...grpc.CallOption) (*Program, error)
	FindProgram(ctx context.Context, in *Program, opts ...grpc.CallOption) (*Program, error)
}

type channelsClient struct {
	cc *grpc.ClientConn
}

func NewChannelsClient(cc *grpc.ClientConn) ChannelsClient {
	return &channelsClient{cc}
}

func (c *channelsClient) GetAvailableStreams(ctx context.Context, in *Channel, opts ...grpc.CallOption) (Channels_GetAvailableStreamsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Channels_serviceDesc.Streams[0], "/stabox.Channels/getAvailableStreams", opts...)
	if err != nil {
		return nil, err
	}
	x := &channelsGetAvailableStreamsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Channels_GetAvailableStreamsClient interface {
	Recv() (*Stream, error)
	grpc.ClientStream
}

type channelsGetAvailableStreamsClient struct {
	grpc.ClientStream
}

func (x *channelsGetAvailableStreamsClient) Recv() (*Stream, error) {
	m := new(Stream)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *channelsClient) GetProgram(ctx context.Context, in *Program, opts ...grpc.CallOption) (*Program, error) {
	out := new(Program)
	err := c.cc.Invoke(ctx, "/stabox.Channels/getProgram", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelsClient) FindProgram(ctx context.Context, in *Program, opts ...grpc.CallOption) (*Program, error) {
	out := new(Program)
	err := c.cc.Invoke(ctx, "/stabox.Channels/findProgram", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChannelsServer is the server API for Channels service.
type ChannelsServer interface {
	GetAvailableStreams(*Channel, Channels_GetAvailableStreamsServer) error
	GetProgram(context.Context, *Program) (*Program, error)
	FindProgram(context.Context, *Program) (*Program, error)
}

// UnimplementedChannelsServer can be embedded to have forward compatible implementations.
type UnimplementedChannelsServer struct {
}

func (*UnimplementedChannelsServer) GetAvailableStreams(req *Channel, srv Channels_GetAvailableStreamsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAvailableStreams not implemented")
}
func (*UnimplementedChannelsServer) GetProgram(ctx context.Context, req *Program) (*Program, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgram not implemented")
}
func (*UnimplementedChannelsServer) FindProgram(ctx context.Context, req *Program) (*Program, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindProgram not implemented")
}

func RegisterChannelsServer(s *grpc.Server, srv ChannelsServer) {
	s.RegisterService(&_Channels_serviceDesc, srv)
}

func _Channels_GetAvailableStreams_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Channel)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChannelsServer).GetAvailableStreams(m, &channelsGetAvailableStreamsServer{stream})
}

type Channels_GetAvailableStreamsServer interface {
	Send(*Stream) error
	grpc.ServerStream
}

type channelsGetAvailableStreamsServer struct {
	grpc.ServerStream
}

func (x *channelsGetAvailableStreamsServer) Send(m *Stream) error {
	return x.ServerStream.SendMsg(m)
}

func _Channels_GetProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Program)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelsServer).GetProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stabox.Channels/GetProgram",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelsServer).GetProgram(ctx, req.(*Program))
	}
	return interceptor(ctx, in, info, handler)
}

func _Channels_FindProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Program)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelsServer).FindProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stabox.Channels/FindProgram",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelsServer).FindProgram(ctx, req.(*Program))
	}
	return interceptor(ctx, in, info, handler)
}

var _Channels_serviceDesc = grpc.ServiceDesc{
	ServiceName: "stabox.Channels",
	HandlerType: (*ChannelsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getProgram",
			Handler:    _Channels_GetProgram_Handler,
		},
		{
			MethodName: "findProgram",
			Handler:    _Channels_FindProgram_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getAvailableStreams",
			Handler:       _Channels_GetAvailableStreams_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "channels.proto",
}
